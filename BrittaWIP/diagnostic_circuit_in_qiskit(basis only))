import numpy as np
import qutip as qt
import math
import operator
from random import randint, uniform, choice,random
import time
import qiskit as q
from qiskit import QuantumRegister,QuantumCircuit,ClassicalRegister,Aer,execute,IBMQ
import qiskit.extensions.unitary as qeu
IBMQ.enable_account("51a5a690e40a42ffa68ae93195aa210f20a89bd6ec6383352ee4c33c84e535910bd50574d89747ef45d0e64f2db022321a64523478f7c767d0b9f1aad08fa3cc")
provider = IBMQ.get_provider()
simulator=Aer.get_backend('qasm_simulator')
from qiskit.quantum_info.operators import Operator
import scipy.sparse as sps
import csv
from qiskit.compiler import transpile, assemble
from qiskit.providers.aer import noise, QasmSimulator, StatevectorSimulator, UnitarySimulator
from qiskit.providers.aer.noise import NoiseModel
#__________________________________________________________________________________________________________#
#splits the data set into testing and training data. Need to initialize empty vectors first
def handleDataset(array,split,trainingSet=[],testSet=[]):
    #with open(filename,'r') as csvfile:
     #   lines = csv.reader(csvfile)
      #  dataset=list(lines)
    split = float(split)
    if split > 1 or split < 0:
        print("Incorrect split input given. Default used.")
        split = 0.66
    dataset=array
    for x in range(len(dataset)-1):
        for y in range(len(dataset[0])-1):
            dataset[x][y]=float(dataset[x][y])
            if random() < split:
                trainingSet.append(dataset[x])
            else:
                testSet.append(dataset[x])
        #print(trainingSet, 'aaaahhh', testSet)
    return 0
#__________________________________________________________________________________________________________#
#Finds the euclidean distance bewteen two vectors of length 'length;
def euclideanDistance(ins1,ins2,length):
    dis=0
    for x in range(length):
        dis += pow((ins1[x]-ins2[x]),2)
    return math.sqrt(dis)
#__________________________________________________________________________________________________________#
#finds the k points nearest a test point
def getKNeighbors(trainingSet,test,k):
    distances=[]
    length=len(test)-1
    for x in range(len(trainingSet)):
        dist=euclideanDistance(test,trainingSet[x],length)
        distances.append((trainingSet[x],dist))
    distances.sort(key=operator.itemgetter(1))
    neighbors=[]
    for x in range(k):
        neighbors.append(distances[x][0])
    return neighbors
#__________________________________________________________________________________________________________#
#determines the classes of a vector of neighbors and returns a prediction of a test point's class
def getResponse(neighbors):
    classVotes={}
    for x in range(len(neighbors)):
        response = neighbors[x][-1]
        if response in classVotes:
            classVotes[response]+=1
        else:
            classVotes[response]=1
        sortedVotes=sorted(classVotes.items(),key=operator.itemgetter(1),reverse=True)
        return sortedVotes[0][0]
#__________________________________________________________________________________________________________#
#Finds the accuracy of a test set prediction
def getAccuracy(testSet, predictions):
    correct=0
    for x in range(len(testSet)):
        if testSet[x][-1] == predictions[x]:
            correct+=1
        print("predicted:" + predictions[x],"actual:" + testSet[x][-1])
    return (correct/float(len(testSet)))*100.0
#__________________________________________________________________________________________________________#
#Performs KNN classification given a dataset, a training-test split, and k
def KNN(path,split,k,testbatch):
    testingset,trainingset=[],[]
    #Insert csv file name and split here:
    #path=input("Give csv file location, remembering to use forward slashes: ")
    if testbatch==[] and split!=None:
        handleDataset(path,split,trainingset,testingset)
    else:
        testingset,trainingset=testbatch,path
     #generate predictions
    predictions,k=[],k
    for x in range(len(testingset)):
        neighbors = getKNeighbors(trainingset,testingset[x],k)
        result = getResponse(neighbors)
        predictions.append(result)
        #print('> predicted=' + repr(result) + ',actual=' + repr(testingset[x][-1]))
    accuracy = getAccuracy(testingset,predictions)
    print('Accuracy: ' + repr(accuracy) + '%')
    return
#__________________________________________________________________________________________________________#
id2=np.eye(2)
#HADAMARDS_________________________________________________________________________________________________#
def alter_hadamard(cat):
    theta = uniform(0.0, math.pi * 2.0)
    phaser = randint(0, 3)
    if phaser == 0:
        cat=cat+'_PHASEGATE1'
    elif phaser == 1:
        cat=cat+'_RZ1'
    elif phaser == 2:
        cat=cat+'_RY1'
    else:
        cat=cat+'_GLOBALPHASE1'
    return theta,cat
#__________________________________________________________________________________________________________#
from random import choice
def h_reassign(cat_alt):
    seed = choice([0,1])
    if seed == 0:  # alter whole hadamard
        ang = uniform(0.0,math.pi*2.0)
        cat_alt=cat_alt+'_GLOBALPHASE2'
        return ang,cat_alt
    if seed == 1:  # alter specific hadamard
        ang,cat_alt = alter_hadamard (cat_alt)
        return ang,cat_alt
#RANDOM UNITARIES__________________________________________________________________________________________#
def random_angles():
    #gets a random value for each variable in the gate
    choice=randint(1,4)
    unitary_gate=()
    if choice==1: #Pauli-Y Gate
        unitary_gate=(0.0,math.pi/2,2*math.pi,math.pi/2,True)
    elif choice==2: #Pauli-Z Gate
        unitary_gate=(0.0,0.0,math.pi,0.0,True)
    elif choice==3: #S Gate
        unitary_gate=(-math.pi/2,math.pi,math.pi,math.pi,False)
    elif choice == 4: #T Gate
        unitary_gate = (-math.pi/4,math.pi/2,2*math.pi,0.0,False)
    delta,alpha,theta,beta,value = unitary_gate
    return delta,alpha,theta,beta,value
#__________________________________________________________________________________________________________#
def random_altered_unitary_gate(delta,alpha,theta,beta,value):
    delta2,alpha2,theta2,beta2=delta,alpha,theta,beta
    if delta==0.0 and alpha==0.0 and theta==math.pi and value==True:
        angles = ['delta','alpha','beta']
    else:
        angles=['delta','alpha','theta','beta']
    altered_variable=choice(angles)
    if altered_variable=='delta':
        delta2 = uniform(0.0,2.0*math.pi)
    if altered_variable=='alpha':
        alpha2 = uniform(0.0,2.0*math.pi)
    if altered_variable=='theta':
        theta2 = uniform(0.0,2.0*math.pi)
    if altered_variable=='beta':
        beta2 = uniform(0.0,2.0*math.pi)
    if delta==delta2 and alpha==alpha2 and theta==theta2 and beta==beta2 and value==value:
        return random_altered_unitary_gate(delta,alpha,theta,beta,value)
    return [delta2,alpha2,theta2,beta2,value]
#__________________________________________________________________________________________________________#
def unitary_gate(choice):
    delta,alpha,theta,beta,value = random_angles()
    if choice:
        matrix,[delta,alpha,theta,beta,value]=random_altered_unitary_gate(delta,alpha,theta,beta,value)
    return [delta,alpha,theta,beta,value]
#__________________________________________________________________________________________________________#
def rot(qubits,value,former_inds):
    a = randint(0, qubits - 2)
    b = randint(a + 1, qubits - 1)
    if value == True:
        if (a, b) != former_inds:
            return (a, b)
        else:
            return rot(qubits, True, former_inds)
    else:
        return (a, b)
#CIRCUIT GENERATION________________________________________________________________________________________#
#Generates a random circuit
def arb_circuit_generator(length,qubits):
    circuit,angles,indices,Had,CNOT,Ran=[],[],[],0,0,0
    while len(circuit)<length:
        seed=randint(1,3)
        if seed ==1:
            indices.append(randint(0, qubits-1))
            circuit.append("Hadamard")
            angles.append(None)
            Had = Had +1
        if seed == 2:
            indices.append(rot(qubits,False,None))
            circuit.append("CNOT")
            CNOT = CNOT +1
            angles.append(None)
        if seed == 3:
            angles.append(unitary_gate(False))
            indices.append(randint(0, qubits-1))
            circuit.append("Random Unitary")
            Ran = Ran +1
    composition = ["Hadamards:",Had,"CNOT:",CNOT,"Random Unitary:",Ran]
    return (circuit,angles,composition,indices)
#CATEGORIES________________________________________________________________________________________________#
def categorize(circuit):
    it_not,it_h,it_rand,it_id,cat=1,1,1,0,[]
    for i in range(len(circuit)):
        if circuit[i] in cat:
            if circuit[i] == "Hadamard":
                it_h+=1
                cat.append("Hadamard" + str(it_h))
            elif circuit[i] == "CNOT":
                it_not+=1
                cat.append("CNOT" + str(it_not))
            elif circuit[i] == "Random Unitary":
                it_rand+=1
                cat.append("Random Unitary" + str(it_rand))
        else:
            cat.append(circuit[i])
        i+=2
    return(cat)
#Input vectors__________________________________________________________________________________________#
def start_circ(qs):
    q1=QuantumRegister((2*qs)+1)
    c1=ClassicalRegister(1)
    qc1=QuantumCircuit(q1, c1)
    qc1.h(2*qs)  # ancilla
    return qc1

def gen_initial(qs):
    group=[]
    bins=['0001','0010','0100','1000']
    for bin in bins:
        qc=start_circ(qs)
        ct=-1
        for num in bin:
            ct += 1
            if num == '1':
                qc.x(ct)
                qc.x(ct + qs)
        group.append(qc)
    return group
#Qiskit circuit____________________________________________________________________________________________#
def global_phase(circuit, q, theta, n):
    if type(q)==bool:
        for i in range(n):
            global_phase(circuit,[i],theta,n)
    else:
        for j in q:
            circuit.u1(theta, j)
            circuit.x(j)
            circuit.u1(theta, j)
            circuit.x(j)
    return
#__________________________________________________________________________________________________________#
import cmath
def phasegate(theta):
    gate=np.array([[1,0],[0,cmath.exp(1.0j*theta)]])
    return gate
#__________________________________________________________________________________________________________#
def rndUnitary(angs):
    delta, alpha, theta, beta, value=angs[0],angs[1],angs[2],angs[3],angs[4]
    gate=(qt.qip.operations.phasegate(delta)*qt.qip.operations.rz(alpha)*qt.qip.operations.ry(theta)*qt.qip.operations.rz(beta)).full()
    if value == True:
         gate=(qt.Qobj(gate)*qt.Qobj(np.array([[0,1],[1,0]]))).full()
    return gate
#__________________________________________________________________________________________________________#
def decompose(cat, index, ang, c, qs): #  qs is number of qubits
    z=index
    hads=['GLOBALPHASE2','GLOBALPHASE1','RY1','RZ1','PHASEGATE1']
    if 'Hadamard' in cat:
        if ang==None:
            c.h(z)
        elif ang!=None:
            if hads[0] in cat:
                c.h(z)
                global_phase(c, True, ang, qs)
            elif hads[1] in cat:
                c.h(z)
                global_phase(c,[z],ang,qs)
            elif hads[2] in cat:
                c.h(z)
                c.ry(ang,z)
            elif hads[3] in cat:
                c.h(z)
                c.rz(ang,z)
            elif hads[4] in cat:
                c.h(z)
                rgate=qeu.UnitaryGate(phasegate(ang))
                c.unitary(rgate, [z])
    elif 'CNOT' in cat:
        c.cx(z[0],z[1])
    elif 'Random Unitary' in cat:
        agate=qeu.UnitaryGate(rndUnitary(ang))
        c.unitary(agate,[z])
    return
#__________________________________________________________________________________________________________#\

def to_qiskit(initials, cat, indicesERR, anglesERR, qs, real_run, params):
    print(qs)
    device = provider.get_backend(params[0])
    probs,index=[],0
    for c in initials:
        for m in range(len(indicesERR)):
            decompose(cat[m],indicesERR[m],anglesERR[m],c,qs)
    for c in initials:
        for j in range(qs):
            c.cswap(2*qs,j,j+qs)
        c.h(2*qs)
        c.measure(2*qs,0)
        shots=1000
        if real_run==True:
            result=execute(c,backend=device,shots=shots).result()
            counts=[result.get_counts(i) for i in range(len(result.results))]
            fin = counts[0]['0'] / shots
            probs.append(fin)
            index += 1
        else:
            [noise_model,basis_gates] = params[1:] #coupling model makes this take an obscene amount of time
            result = execute(c, backend=simulator, shots=shots,noise_model=noise_model,basis_gates=basis_gates).result()
            counts = [result.get_counts(i) for i in range(len(result.results))]
            fin = counts[0]['0'] / shots
            probs.append(fin)
            index += 1
    return probs

def bill_bailey(angles,cat,qubits,indices,probabilities,cat2,ci,i,real_run,params):
    if "Hadamard" in cat[i]:
        angERR = angles.copy()
        angs, cat2[i] = h_reassign(cat2[i])
        angERR[i] = angs
        probs = to_qiskit(ci, cat2, indices, angERR, qubits, real_run,params)
        probs.append(cat[i])
        probabilities.append(probs)
    elif "Random" in cat2[i]:
        angERR = angles.copy()
        (delta, alpha, theta, beta, value) = angles[i]
        angERR[i] = random_altered_unitary_gate(delta, alpha, theta, beta, value)
        probs = to_qiskit(ci, cat2, indices, angERR, qubits, real_run,params)
        probs.append(cat[i])
        probabilities.append(probs)
    elif "CNOT" in cat2[i]:
        indERR, angERR = indices.copy(), angles.copy()
        indERR[i] = rot(qubits, True, indices[i])
        probs = to_qiskit(ci, cat2, indERR, angERR, qubits, real_run,params)
        probs.append(cat[i])
        probabilities.append(probs)
    return
#__________________________________________________________________________________________________________#
def colin_mochrie(angles,pop,cat,qubits,indices,real_run,params):
    probabilities,num_states=[],2**qubits
    if real_run==True:
        for i in range(int(len(indices)/2)): #will not go through entire circuit--only half here
            ci = gen_initial(qubits)
            cat2=cat.copy()
            bill_bailey(angles, cat, qubits, indices, probabilities, cat2, ci,i,real_run, params)
    else:
        for j in range(pop):
                for p in range(len(indices)):
                    ci=gen_initial(qubits)
                    cat2=cat.copy()
                    bill_bailey(angles,cat,qubits,indices,probabilities,cat2,ci,p,real_run, params)
    return probabilities
#__________________________________________________________________________________________________________#
def main():
    pop=8                                         #input #("How many of each gate do you want to populate? ")
    pop=int(pop)
    qubits=4 #input                                                                    #("How many qubits? ")
    qubits=int(qubits)
    length=8 #input                                                     #("how many gates in the circuit? ")
    length=int(length)
    split=0.8 #input                  #("Give training set split, in the form of a number between 0 and 1: ")
    k=5  #input                                                                         #("Give a k value: ")
    k=int(k)
    dev_name='ibmq_16_melbourne'
    device = provider.get_backend(dev_name)
    properties = device.properties()
    gate_lengths = noise.device.parameters.gate_length_values(properties)
    noise_model = noise.device.basic_device_noise_model(properties, gate_lengths=gate_lengths)
    basis_gates = noise_model.basis_gates
    params=[dev_name, noise_model,basis_gates]

    (circuit, angles, composition, indices) = arb_circuit_generator(length, qubits)
    cat, n = categorize(circuit), 2 ** qubits
    print(cat, '\n', composition)
    index = 0

    probs = colin_mochrie(angles,pop,cat,qubits,indices,False, params)
    KNN(probs, split, k, [])
    print('creating hardware test batch...')
    testbatch= colin_mochrie(angles,1,cat,qubits,indices,True,params)
    KNN(probs,None,k,testbatch)
    index+=1

    return

start_time = time.time()
main()
print("--- %s seconds ---" % (time.time() - start_time))
